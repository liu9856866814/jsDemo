/*
* 正则是专门处理字符串的规则:
*   1. 正则匹配 RegExp.prototype.test()
*   2. 正则捕获 RegExp.protyotype.exec() String.prototype.match();
* */

// 正则由元字符和修饰符组成
// 元字符:
// 特殊元字符
/*
* \d 匹配0-9任意一个数字
* \D 除0-9任意一个字符
* \w 数字/字母/下划线(_)中的任意一个字符
* \W 除\w 以外的任意一个字符
* \s 匹配空白符 (空格、制表符\t \n \r)
* \b 边界(字母和非字母连接处)
* \n 匹配换行符
* . 除了\n 以外所有的字符
* \ 转义符,把特殊元字符转义成普通元字符, . 表示除\n以外的任意字符, \. 表示小数点
* x|y x或y中的一个
* [xyz] x或y或z中的一个
* [0-9] \d 匹配0-9中的任意一个数字
* [a-z] 小写字母a-z中的任意一个字符
* [A-Z] 大写字母A-Z中的任意一个字符
* [^xyz] 除x/y/z以外的任意字符
*
* ^ 以某个元字符开头
* $ 以某个元字符结尾
* () 表示正则分组
* (?:) 表示当前分组只匹配不捕获
* (?=) 正向预查 /x(?=y)/ 匹配后面跟着y的x
* (?!) 负向预查 /x(?!y)/ 匹配后面没跟着y的x
*
* */
// 量词元字符
/*
* * 0-多次
* + 1-多次
* ? 0-1次
* {n} n次
* {n,} 至少n次
* {n,m} n-m次
* */

// 普通元字符: 除了特殊的元字符/量词元字符以外的其他元字符都是普通元字符

// 修饰符
// i ignorecase 忽略大小写
// m multiline 多行匹配
// g global 全局匹配

// [方括号细节问题]:
// 1. 某些特殊元字符出现在方括号中,就表示原义: [.,] [*] [?] [+]
// 2. [183] 出现在方括号中的多位数表示多个一位数, [183] 表示1/8/3  [23-68] 表示2 / 3-6 / 8
// 3. 如果方括号表示一个范围时,只能正着写,小的在前面,大的在后面,不能倒着写;

let reg2 = /^[23-59]$/g; // 2 或者 3-5 或者 9 这个范围中的一个数字
reg2.test('35');

// 正则捕获: exec方法/match方法
// exec如果能捕获,返回一个数组,数组第一项是大正则捕获到的内容,如果有分组,从第二项开始起是分组捕获的内容;
// 正则捕获一次只能捕获一个,如果想要都拿到,就需要多次执行exec方法
let reg3 = /zhufeng\d{4}/;
let str = 'hello2019 zhufeng2019 zhufeng2020';
// console.log(reg3.exec(str)); // ['zhufeng2019'....]
// console.log(reg3.exec(str)); // ['zhufeng2019'....]
// console.log(reg3.exec(str)); // ['zhufeng2019'....]
// 上面三次捕获结果相同,正则捕获具有懒惰性.正则在捕获时每次都是从开头开始查找,一旦找到一个符合条件的就捕获,不管后面是否还
// 有符合条件的都会停止查找;
// 在正则后加全局修饰符g,可以解决懒惰性的问题
let reg4 = /zhufeng\d{4}/g;
// console.log(reg4.exec(str)); // ['zhufeng2019'....]
// console.log(reg4.exec(str)); // ['zhufeng2020'....]
// console.log(reg4.exec(str)); // null

// 加了g以后,正则会按照lastIndex去查找,每捕获一次,就会更新一次lastIndex的值,下次再捕获就从lastIndex记录的索引位置开始找.
// 但是捕获到最后一个符合条件的以后,再捕获就会返回null,当返回null后再捕获又会从头开始捕获.

// 分组捕获: 在正则中用小括号把我们想要的部分括起来.此时正则捕获结果从第二项开始起就是分组捕获的内容,有几个分组,就有几项
let reg5 = /zhufeng(\d{4})/g;
let reg6 = /(zhufeng)\d{4}/g;
console.log(reg6.exec(str));
console.log(RegExp['$&']); // $&只能用[];
console.log(reg5.exec(str)); // ['zhufeng2019', '2019'....]
console.log(RegExp.$1); // $1-$9 表示第一到第9个分组 $&大正则捕获到的内容
// 第一次执行 reg6.exec(str) 就相当于给RegExp.$1 赋值成'zhufeng'字符串
// 第二次执行 reg5.exec(str) 就相当于给RegExp.$1 赋值成'2019'
// 一个属性被赋值两次，代表的是最后一次被赋的值

// 正则捕获的贪婪性：正则在捕获时，一旦捕获到就会按照最大的长度进行捕获。
let str2 = '12345678';
console.log(/\d{2,6}/.exec(str2)); // 12345678
console.log(/\d*/.exec(str2)); // 12345678
// 解决贪婪性：在量词元字符后跟 ?

// match 方法：
// 1. 使用的正则带g和不带g的区别
// match 方法使用的正则不带g的话，返回的结果和exec相同；如果带g就会把符合规则的一次性全部拿到；

// 2. 关于分组捕获: match不能进行分组捕获，它不理会分组；


