/*
* 1. 求数组极值
*   1.1 先排序，再取极值，升序排列第一个是最小值；降序排列第一个是最大值
*   1.2 假设法，假设某一个值是极值，用剩下的和假设值比较，当遇到假设不成立的值时，然后让假设值等于这个值，一轮比较完毕后，
* 即可获取到极值；
*   1.3 排序算法（和先排序再取值是一种思路）
*   1.4 Math.max() 和 Math.min();这两个方法只能接收一个一个的数字；所以有两个方案：
*       1.4.1 把数组变成一项一项的 ... 扩展运算符 Math.max(...ary)
*       1.4.2 让Math.max 和 Math.min 接收一个数组，使用apply方法，让这两个方法可以接收一个数组
*   1.5 eval() + 字符串：利用eavl() 方法可以把字符串解析成js代码，并且执行这些代码；eval(`Math.min(${数组.toString()})`)
*
* 2. 类数组转数组
*   类数组：有length有索引的对象；
*   因为数组有很多的方法，但是数组的方法只能给数组用，类数组如果也想用数组方法，必须先转成数组；
*   2.1 for循环遍历类数组，把类数组中的项添加到新数组中（无兼容性问题）
*   2.2 扩展运算符，把类数组展开到一个数组中 ES6 新特性，IE低版本不兼容
*   2.3 Array.from() 把类数组对象转成数组(类数组对象、iterator对象...);ES6 新增特性，IE低版本不兼容
*   2.4 借用Array.prototype.slice方法：
*       Array.prototype.slice.call(类数组对象)
*       [].slice.call(类数组对象) [].slice 仅仅是通过原型链找到slice方法；（IE低版本不能用）
*   3. js异常处理：js是单线程的，在执行js代码时，有报错后面的就不执行了；我们把报错的代码写在try中，一旦报错，错误就会被捕获。
*       try{
*           有可能会报错的代码
*       }catch(e){
*           上面try中的代码报错后会执行catch中的代码
*           e 错误对象：这里面包含着try中报错信息；拿到错误信息后，可以选择抛出异常，或者有需要时可以把这个报错信息传给服
* 务器{做性能监控、监控日志[听云]}
*       }
*
*       try-catch 语句有益于增强代码的健壮性（健壮性强的代码量多，当和效率冲突时首先保证效率）；
* 3. js异常处理
*
* 4. 方法封装
*
* 5. 箭头函数
* */

var ary = [1,5,10,3,2];
let min = Math.min.apply(null,ary); // apply接收一个打包传递的数组，它内部会把这个数组拆成一项一项的再传给min方法，所以
// min方法还是拿到一个一个的数字；

// let str = `javascript;${变量或者表达式}`;
var arrLike = {
    0: 'a',
    1: 'b',
    2: 'c',
    length:3
};
let arr = [...arrLike];//把类数组展开到数组中






