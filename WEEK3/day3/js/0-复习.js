/*
* 正则：js内置类RegExp (RegExp 是一个函数数据类型的) 专门用来处理字符串的规则；处理分为两种：
*   1. 正则匹配，判断某个字符串是否符合某个规则 RegExp.prototype.test()
*   2. 正则捕获，把符合规则的字符串获取到 RegExp.prototype.exec() String.prototype,match();
* 正则是由元字符和修饰符组成：/元字符/修饰符；
* 元字符：
*   1. 特殊元字符
*       \d 0-9 任意一个数字
*       \D 除了0-9以外的任意一个字符
*       \w 数字 字母 _ 中的任意一个
*       \W 除了数字 字母 下划线以外的任意一个
*       \s 匹配空白符 (空格 制表符\t \n \r )
*       \b 匹配单词边界(字母与非字母连接处)
*       \n 匹配换行符
*       . 除\n以外的任意字符
*       \ 转义符,把特殊元字符转义成字符原义
*       ^ 读作caret 表示以某个元字符开头
*       $ 表示以某个元字符结束
*       x|y 表示x或y中的一个
*       [xyz] x/y/z中的一个
*       [a-z] 匹配a-z中的一个小写字母
*       [A-Z] 匹配A-Z中的一个大写字母
*       [0-9] 匹配0-9中的一个数字 \d
*       [a-zA-Z0-9] 等价于\w
*       [^xyz] 除了xyz以外的任意一个字符
*       () 正则分组
*       (?:) 取消分组捕获
*       (?=) 正向预查
*       (?!) 负向预查
*   2. 量词元字符
*       * 0-多次
*       + 1-多次
*       ? 0-1次
*       {n} n次
*       {n,} 至少n次
*       {n,m} n-m次
*   3. 普通元字符:除了特殊元字符/量词元字符以外都是普通元字符
* 修饰符：
*   1. i ignorecase 忽略大小写匹配
*   2. m multiline 多行匹配
*   3. g global 全局匹配
*
* */
// 匹配字符串 \d
let reg = /\\d/; // 正则中元字符\d 需要转义 \\d
// console.log(reg.test('\\d')); // 字符串中的一个 \ 是转义符,如果在字符串使用这个 \ , 在字符串中也需要转义一次; \\d -> \d
// console.log('\\n'); // 把字符串中\n 换行符通过\ 转义成普通字符串\n
// console.log('\\'); // 把 后面的\ 转义成普通的斜杠,第一个斜杠作为转义符,不会输出, 注意写字符串中的\ be careful;

let reg2 = /^$/g; // 匹配空字符串的方法
let reg3 = /-/g; // - 表示一个普通元字符

// 正则匹配: 用正则的test方法
let reg4 = /^1\d{7}(\d)\1{2}$/;
// console.log(reg4.test('12345678000')); // true

// []的细节问题:
// 1. 有些特殊元字符在方括号中不再具有特殊意义,代表字符原义: [.] [+] [*] [?]
// 2. 中括号连续出现的多位数,不是代表一个多位数,而是代表多个一位数; [183] 不代表183 代表 三个数之一
// [23-68] 表示2 或3-6或 8,如果想表示23-68 ,就需要拆
// 23-29 2[3-9]
// 30 - 59 [3-5][0-9]
// 60-68 6[0-8]
// 拼接起来: /^(2[3-9]|[3-5]\d|6[0-8])$/ 加了^和$ 表示既是以这个内容开头,又要以这个结尾,就是只能是这个内容.
// 3. 表示范围: 前面的必须比后面小 不能写z-a 9-0 Z-A!!!

// 正则捕获: 正则捕获使用正则exec方法/字符串match方法
let id = '0511120117'; // 前2位院系 2位专业 入学2位年级 2位班级 2位编号
let reg5 = /(\d{2})(\d{2})(\d{2})(\d{2})(\d{2})/;
console.log(reg5.test(id));
let data = {
    '05': '城建学院',
    '11': '土木工程',
    '12': '2012年',
    '01': '一班',
    '17': '马宾'
};
// 城建学院土木工程专业2012年一班马宾
let str = data['05'] + data['11'] + '专业' + data['12'] + data['01'] + data['17'];
console.log(str);

// 用正则捕获把数字从字符串中取出来
let execResult = reg5.exec(id);
console.log(execResult);

/*
* [
* "0511120117", // 这是大正则捕获到的内容
* "05",  // 第一个分组捕获到的内容 院系
* "11",  // 第二个分组捕获到的内容 专业
* "12",  // 第三个分组捕获到的内容 入学年份
* "01",  // 第四个分组捕获到的内容 班级
* "17",  // 第五个分组捕获到的内容 编号
* index.html: 0,
* input: "0511120117",
* groups: undefined
* ]
* */
// let str2 = data[execResult[1]] + data[execResult[2]] + data[execResult[3]] + data[execResult[4]] + data[execResult[5]];
let str2 = '';
for (let i = 1; i < execResult.length; i++) {
    let item = execResult[i];
    str2 += data[item];
    if(i === 2) str2 += '专业';
}
console.log(str2);
// 通常使用[索引]的方式从捕获结果中获取分组捕获的内容;
// RegExp 有几个属性,保存着正则分组捕获到的内容
// $1-$9 表示第1到第9个分组捕获到的内容(大于9的分组要自己通过索引的方式获取)
// RegExp['$&']; 表示大正则捕获到的内容
// console.log(RegExp.$1); 第一个分组
// console.log(RegExp.$2); 第二个分组
// console.log(RegExp.$3); 第三个分组
// console.log(RegExp.$4); 第四个分组
// console.log(RegExp.$5); 第五个分组
// console.log(RegExp['$&']); 大正则捕获到的内容

// 正则捕获的懒惰性: 每次正则捕获时从索引为0的位置开始查找,捕获到第一个符合条件的就停止捕获,不管后面有没有符合条件的.
// 解决懒惰性: 在正则后加修饰符 g

// 正则捕获的贪婪性: 一旦成功捕获,按照符合条件最长的长度进行捕获;
// 解决贪婪性: 量词元字符后面加 ?

// match 字符串方法:
// match 使用不带g的正则,捕获到的内容和exec捕获内容一样
// match 使用带g的正则,会把所有匹配到的内容放到数组中,一次性捕获.

// lastIndex 下一次捕获或者匹配开始的位置,当正则找到末尾时,再捕获会返回null,但是下一次lastIndex会从0开始;





