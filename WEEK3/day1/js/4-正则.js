/*
* 目标：
*   1. 理解正则的作用
*   2. 掌握特殊正则的构成
*   3. 掌握特殊元字符
* */
// 正则：RegExp 类（regular expression）
// 正则是一个专门用来处理字符串的规则，这种处理分为两种：
// 判断字符串是否符合这个规则，即正则匹配
// 把符合规则的字符串获取到，即正则的捕获

// 学习正则就是编写一个正则

// 创建一个正则
let reg = /^\d+$/g; // 字面量的创建方式
let reg2 = new RegExp('\\d+','g'); // 实例的创建方式创建

// 正则的构成（字面量）：正则是由元字符和修饰符组成；两个斜线中包裹的叫做元字符；

// 元字符
/*
* 特殊元字符
* \d 0-9的任意一个数字
* \D 除0-9以外的任意一个字符
* \w 数字、字母、_ (下划线)中的任意一个
* \s 匹配一个空白符（空格、制表符\t）
* \b 匹配边界，'zhu-feng' 边界就是字母和非字母连接的地方，z的左边，u的右边，f的左边，g的右边都是边界
* \n 匹配一个换行符
* . 匹配除换行符\n以外的任意一个字符
* \ 转义符，把具有特殊意义的字符转义成普通字符；比如说正则中 . 表示除换行符\n以外的任意字符。但是 \. 就表示普通小数点；
*
* ^(读作caret) 表示以某个元字符开头
* $ 表示以某个元字符结尾
* x|y 表示x或者y中的任意一个
* [xyz] 表示x/y/z中的任意一个
* [a-z] 表示匹配a-z的中一个小写字母
* [0-9] 表示0-9中的任意一个数字
* [A-Z] 表示匹配A-Z的中一个大写字母
* [^abc] 除a/b/c以外的任意一个字符
* () 正则分组
* (?:) 表示当前分组只匹配不捕获
* (?=) 正向预查
* (?!) 负向预查
*
*
* */

// 量词元字符：表示次数或者个数的
/*
* * 表示出现0次到多次
* ? 表现出现0次到1次（出现或者不出现）
* + 出现1到多次
* {n} 表示出现n次
* {n,}表示至少出现n次
* {n,m} 表示出现n次到m次
*
* */

// 普通元字符：除了特殊元字符、量词元字符以外的其他元字符都是普通元字符

// 修饰符
// i: ignorecase 忽略大小写匹配
// m: multiline 多行匹配
// g: global 全局匹配

let reg3 = /\d/;
let str = '1';
console.log(reg3.test(str)); // true;
// RegExp.prototype.test() 方法：这个方法用来匹配，检测一个字符串是否符合当前正则，如果符合，就返回true,不符合返回false;





