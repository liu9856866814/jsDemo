// 第一、二周
/*
* 1. 变量提升
*  1.1 在全局作用域开辟后，js代码执行前，浏览器会对带var和带function的进行提前声明或定义；
*       声明：声明一个变量，告诉浏览器有这么一个变量
*       定义：给变量赋值；
*       对带var的：只声明不定义，变量的值是默认值undefined
*       对带function的：既声明又定义；
*  1.2 JS运行机制：页面打开时会首先形成一个全局作用域(window),接着对全局中的变量进行提升（处理全局中的带var和带function）。
* 变量提升结束后，js代码从上到下执行，执行时遇到 变量 = 值 开始对变量进行赋值：
*   如果赋值一个基本数据类型的值，直接在当前作用域中存储这个值；
*   如果赋值一个引用数据类型的值，浏览器会开辟一个堆内存空间存储引用数据类型的值（对象存键值对/数组存键值对+length/函数存代码
* 字符串），然后把这个堆内存空间地址赋值给变量。
*    如果遇到函数执行：函数名（实参）
*    1）新开辟一个私有作用域
*    2）形参赋值（形参也是私有变量）
*    3）私有作用域中的变量提升
*    4）js代码从上到下执行
*
*   ！！ 变量提升只发生在当前作用域。私有变量提升也只能提升到私有作用域中，不能提升到全局作用域；
*
* 2. 作用域、作用域链
*   作用域：供js代码执行的环境，保存基本数据类型的值；分为：
*   1）全局作用域
*   2）私有作用域
*   3）块级作用域
*   作用域链：变量查找机制；当引用一个变量时，浏览器首先在当前作用域查找，如果找到就使用当前作用域中的变量；如果当前作用域
* 中没有，就去上级作用域查找，如果上级作用域还没有就继续向上查找，一直找到window为止；如果是引用这个变量取值就会报错；如果
* 是赋值，就给window添加一个同名的属性；
*   怎么确定上级作用域？函数声明时所在的作用域就是该函数的上级作用域；
*
* 3. 堆栈内存的创建释放:
*   浏览器的引擎中有两种内存：
*   堆内存：存储引用数据类型的值；
*   堆内存创建：浏览器遇到引用数据类型时，就会开辟一个堆内存空间；
*   堆内存销毁：当所有引用该内存的变量或者对象的属性都不再引用这个堆内存的时候，浏览器在空闲时就会回收这个堆内存。
*   栈内存：栈内存就是作用域，存储基本数据类型的值，供js代码执行的环境；
*   创建栈内存：
*       1) 新开页面时，浏览器会形成一个顶层栈（全局作用域window）；
*       2) 函数执行时浏览器会新开辟一个私有栈内存（私有作用域）
*   栈内存销毁：关闭页面时全局作用域会销毁，函数执行完毕一般私有栈就会销毁，但是有些特殊情况栈内存不销毁；
*
*   栈内存不销毁的情况：
*   1）函数返回值是引用数据类型且被函数外面的变量或者对象的属性占用。
*   2）函数中的某一部分引用数据类型，被函数外的变量或者属性占用。
*   3) 当函数return一个函数，这个return出来的函数紧接着就执行，此时外面的函数作用域暂时不销毁，等后面的执行完成后作用域就销毁了。
*
* 4. 闭包、this
*   函数执行时形成的私有作用域，保护内部变量不受外界干扰，这种机制称为闭包;常见的闭包形式就是在一个函数中return一个函数.
*   1) 事件函数中的this指向绑定改事件的元素
*   2) 全局中的this指向window
*   3) 自执行函数中的this指向window
*   4) 定时器中的回调函数的this指向window
*   5) 方法调用时，看方法名前面有没有点.，点前面是谁方法中的this就是谁，没点this指向window
*   6) 箭头函数中的this指向声明时所在作用域中的this
*   7) 构造函数中的this指向当前构造函数（类）的实例
*   8) call/apply/bind 可以修改this
*
* 5. 面向对象的封装方式（单例、工厂、构造函数、原型模式）：封装的目的就是为了创建对象；
*   5.1 单例模式（高级单例模式）：解决命名空间的问题
*   5.2 工厂模式：是个函数，解决批量生产的问题
*   5.3 构造函数模式：是一个只能用new调用的函数，解决了工厂模式没有类型的问题；
*   5.4 原型模式：解决了共有的属性共享的问题，把公有的属性和方法放到原型上。
*
* 6. 类、原型、对象、原型链
*   类：js中的类（内置类和自定义类）都是一个函数数据类型的，每个类都有一个属性prototype(原型)；
*   原型：prototype是一个对象数据类型的值。原型中天生自带一个特殊的属性constructor,指向当前原型对象的构造函数本身；
*   Array.prototype.constructor === Array -> true
*   对象：实例对象、原型对象、函数对象都有一个__proto__ 属性，这个属性指向当前对象所属类的原型；
* [].__proto__ === Array.prototype -> true
*
* 7. Function、函数的三种角色
*   Function 类：JS中所有的函数都是Function的实例；所有的内置类（Object/Array/RegExp/Date...）都是函数数据类型，所以这些
* 内置类也是Function的实例
*   Object.__proto__ === Function.prototype -> true
*   Function.prototype.__proto__ === Object.prototype ->true
*   函数的三种角色：
*   1）普通函数：
*       执行过程：
*       1. 新开私有作用域
*       2. 形参赋值
*       3. 变量提升
*       4. 执行函数体的代码
*       5. 作用域销毁
*   2）构造函数：
*       执行过程：
*       1. 新开私有作用域
*       2. 形参赋值
*       3. 变量提升
*       4. 隐式创建当前类的一个实例对象，把构造函数中的this指向实例
*       5. 执行构造函数体的代码，this.xxx = xxx 只有通过该方式才能给实例添加私有属性；
*       6. 隐式返回这个实例对象（相当于return this）
*       7. 作用域销毁
*   3）对象：函数还可以当做普通对象一样，可以 函数名.属性名 这样操作；通过 函数名.属性名 = xxx 的方式添加的属性或方法，是函数的
* 静态属性或方法，既不是实例的私有属性也不是公有属性；
*
* 8. call/apply/bind ：用来修改this关键字指向的；
*   call/apply: 修改this关键字，让函数执行；call是一个一个的传参，apply是打包成一个数组传递；
*   bind：修改this关键字，返回一个新函数，不会执行函数；
*
* 9. 面向对象选项卡：多看多写；
*
* 10. 数组极值、类数组转数组、try-catch
*   数组极值：
*     先排序再取值、
*       假设法、
*       Math.max.apply(null,数组)/Math.min.apply(null,数组)；
*       Math.max(...数组) Math.min(...数组)
*     类数组转数组：
*       1) for循环遍历类数组添加到新数组中
*       2) Array.prototype.slice.call(类数组)；
*       3) [].slice.call(类数组)；
*       4) Array.from() ES6 类数组转数组
*       5) 扩展运算符，把类数组展开到数组中
*     try-catch 语句用来做容错处理，
*     try {
*      可能会报错的代码
*     } catch (e){
*       报错之后才会执行catch语句；在这里可以写备选方案
*     }
*
* 11. sort应用
*   1. sort() 不传参能正常排0-9的数字
*   2. sort(callback) 可以排所有的
*     2.1 排数组对象（二维数组）不是只排属性，把这些对象重新排序
*     2.2 排html，找到元素对象和排序维度之间的关系，如元素对象.innerHTML/ 元素对象.getAttribute()
*
* 12. 数组复制（深复制、浅复制）
*   深复制：复制出来的这一份和原来的没关系；
*   浅复制：复制时复制的是引用数据类型的地址；
*   因为,数组项是基本数据类型，数组在存储这一项是时存储的就是这一项的值；但如果数组是引用数据类型，数组存储的就是堆内存地址。
*   JSON.parse(JSON.stringify(对象)) 最简单的深复制的办法
*
* 13. DOM映射：页面中的html元素和通过js相关方法获取来的元素对象或者集合存在映射关系（一个改另一个跟着改）；
*   1. 元素对象.style.backgroundColor = red;
*   2. 把页面中已经存在的DOM元素对象重新appendChild回去时，它不会重新克隆一个元素对象，而是把原来的这个移动到容器末尾。
*   3. 绑定数据之前，获取来的集合是一个空集合，在数据绑定后，集合就有了新插入的元素。querySelectorAll获取来的是一个静态集合，
* 这种集合是掐断了DOM映射的，如果在开头用querySelectorAll方法获取的对象，在绑定数据后需要重新获取。
*
* 14. JSON数据：前后端交互的数据格式；
*   JSON格式对象：属性名和属性值都被双引号包裹，如果值是数字可以不包；
*   let obj = {"name":"zf"};
*   let ary = [{"name":"zhufengFE"},{"name":"zhufengUI"}];
*
*   JSON字符串：长的像JSON对象的字符串
*   let obj = '{"name":"zf"}';
*   let ary = '[{"name":"zhufengFE"},{"name":"zhufengUI"}]';
*
*   互转： window.JSON
*   JSON.stringify() 对象转JSON格式字符串
*   JSON.parse() JSON格式字符串转对象
*
* 15. ajax
*   1. 创建一个ajax实例
*   let xhr = new XMLHttpRequest();
*   2. 调用xhr的open方法，配置请求
*   // http method: 请求方式
*   // URL: 服务端接口地址
*   // ASYNC: true 异步，false 同步
*   xhr.open(httpMethod',URL, ASYNC);
*   3. 监听xhr的onreadystatechange事件
*   xhr.onreadystatechange = function(){
*       if (xhr.readyState === 4 && xhr.status === 200){
*           console.log(xhr.responseText); // 从服务端获取来的数据保存在 xhr.responseText属性上；
*       }
*   }
*   4. 发送请求
*   xhr.send();
*
* 16. 数据绑定:把数据搞成html，插入到页面中；
*   1. 动态创建DOM和插入DOM
*   document.createElement()
*   appendChild()
*   2. 字符串拼接+innerHTML
*   传统字符串拼接
*   es6模板字符串
*   模板引擎
*   DOM回流：元素的插入、删除、大小、位置的改变，会引起浏览器对其他元素位置重新计算，极度消耗性能；
*   DOM重绘：元素的某些css样式如背景色、字体颜色等发生改变时，浏览器会重新渲染元素；
*   文档碎片：减少DOM回流的有效方式：
*       frg = document.createDocumentFragment();
*
* 17. 商品排序
*
* */

function sum(a,b) {
    var total = 0; // sum 不执行，total不会提升
}

({}) ==={};

// 栈内存不销毁
let seo = (function (x) {
    // x = 10;
    // 当把一个自执行函数赋值给变量时，其实并不是把自执行函数给了变量，是把自执行函数的返回值给了变量
    return {
        title: 'zf',
        description: '前端教程',
        keywords: '前端'
    }
})(10);

let data = null;
function minus() {
    data = {
        x:1,
        y:10
    }
}
minus();

function f1() {
    return function () {
        console.log(a);
    }
}
let f = f1(); // f1的作用域不销毁
f1()(); // f1的作用域暂时不销毁，当后面的小括号的执行完成后，作用域就会销毁

// 面试题：写一个闭包
function sum2(a) {
    return function (b){
        console.log(a + b);
    }
}

// 构造函数
function Foo() {
    let name = 'xyz'; // 如果只是声明变量，和实例无关。
    function getName() { // 这个getName 不是给实例添加私有属性
        console.log("name");
    }
    this.name = name;
}
let f2 = new Foo();


