/*
* 目标：
*   1、掌握js的作用域分类，以及作用域的作用
*   2、理解js的运行机制，函数运行的机制
* */

/*
* js代码执行分为两个阶段：
*   1、变量提升：js代码之前对所有带var和function的进行提前声明或者定义；其中带var的只声明不定义，变量值默认undefined；对带function的既声明又定义；
*   2、js的执行阶段：
* */

// js的运行环境：作用域（栈内存 stack）
// 作用域的作用：给js提供运行环境，存储基本数据类型；

// 作用域的分类：
/*
* 1、全局作用域：浏览器打开一个页面的时候，首先形成一个全局作用域，用来执行全局中的代码，全局作用域就是window对象
* （全局对象的一个实现，在浏览器中是window，在Node.js中是Global）
* 2、私有作用域（函数作用域）：函数执行时形成的作用域；
* 3、块级作用域;把代码块（if/for循环的代码块、、、）变成作用域，功能和私有作用域类似，是ES6新增；
* */

// js代码的运行机制：
var num = 100;
console.log(num);
var obj = {
    name:"珠峰"
};
function fe(){
    console.log('FE from zhufeng');
}
fe();
fe();
/*
* js的运行机制:
* 1.js代码执行之前，浏览器会为其开辟全局作用域，然后对全局中的变量进行提升操作，对带var和带function进行提前声明或定义；
* 2.变量提升结束后，js代码开始从上到下执行；执行过程中对带var的变量进行赋值；
*   2.1 如果是赋值一个基本数据类型的值，直接把基本数据类型的值存在作用域中，并且把变量和值关联起来；
*   2.2 如果是赋值一个引用数据类型，浏览器会开辟一个堆内存，存储这个引用数据类型的值，再把这个堆内存的地址赋值给变量
*   （这个时候这个内存地址是存在作用域中的）
* 3. 如果执行过程中遇到函数执行会经历以下几步：
*   3.1 浏览器会为函数的代码执行再开辟一个新的作用域（一块新的栈内存）
*   （函数每次执行都是互相独立的，因为每次的执行环境不同）
*   3.2 形参赋值，形参也是变量，把函数执行时实参赋值给形参。
*   3.3 私有作用域中的变量提升，对私有作用域中的带毁掉和带function的提前处理
*   3.4 从上到下执行函数代码
* 4. 如果再遇到函数执行重复第3步
*
*
* */

//私有变量和全局变量：
// 全局变量：在全局作用域中声明的变量
// 私有变量：在私有作用域（函数作用域）声明的变量以及函数的形参也是私有变量

//变量提升只发生在当前作用域中，函数不执行函数里面的私有变量不提升。

function count(){  //count 函数不执行，变量n不提升
    var n = 12;
}
console.log(n);// 引用错误 n is not defined

