/*
* 目标：
*   1. 变量提升
*   2. 变量提升的细节问题
*   3. js作用域、分类
*   4. js运行机制
*   5. 全局变量、私有变量
*   6. 作用域链
*   7. 堆内存的创建释放
*   8. 栈内存的创建、销毁、不销毁的特殊情况
*   9. let、const和var的区别、const的细节问题
*
* */

/*
* 1. 变量提升：js代码执行前，对所有带var和带function的进行提前的声明或定义
*   声明：声明一个变量，告诉浏览器有这么一个变量；
*   定义：给这个变量赋值
*   带var只声明不定义，所以变量的值默认值undefined
*   带function的是声明且定义
*  变量提升后的结论：有多少个var的变量，值是undefined,有多少个function的变量，值是function.
*
* 2. 变量提升的细节问题
*   2.1 等号右侧不参与变量提升，即使是函数也不会提升
*   2.2 变量提升不理会条件，条件为false时，条件中声明的变量或函数也会变量提升；！！更正：函数在条件外是只声明不定义，
* 在条件中是声明且定义的。！
*       写在if条件小括号里的函数，不会参与变量提升，无论在哪使用函数名都会报错！
*   2.3 return右侧的值不会进行变量提升，即使是函数也不行；
*   2.4 return下面的js代码虽然不执行，但会变量提升；
* */
// sum(1,3);
var fn = function sum(a,b) { // 等号右侧不参与变量提升，导致
    return a + b ;
};
// sum(1,3);

console.log(num);//undefined
console.log(foo);//undefined //函数也是undefined
if(false){
    var num = 1;
    function foo() {}
}
console.log(num);//undefined
console.log(foo);//undefined foo是undefined

console.log(num2);// undefined
console.log(foo2);// undefined
if(true){
    var num2 = 1;
    console.log(foo2);// 函数
    function foo2() {}
}
console.log(num2);// 100
console.log(foo2);// 函数，因为条件为true时，执行过foo2的赋值。

// console.log(bar); 报错:引用错误
if(function bar() {}){ // 写在这里的函数不参与变量提升
    console.log(1);
}
// console.log(bar); 报错：引用错误

/*
* js作用域（scope）、运行机制：
*   1. js的作用域的作用：供js代码执行的环境，存储基本数据类型值
*   2. 作用域分类：
*       2.1 全局作用域：当浏览器打开一个页面时，首先形成一个顶层作用域即全局作用域，全局作用域是特殊对象window.
*       2.2 私有作用域（函数作用域）：函数执行时，浏览器会为函数代码执行新开一个环境，即私有作用域
*       2.3 块级作用域：ES6新增的，把代码块变成作用域，作用和私有作用域类似。
*   3. js运行机制：
*       3.1 在js代码执行前，浏览器会开辟一个全局作用域，对全局作用域中的变量进行变量提升；
*       3.2 js代码开始从上到下执行，执行过程中，给普通变量赋值；
*           如果赋值的是基本数据类型的值，就在当前作用域中存储基本数据类型值，然后把变量和值关联起来。
*           如果赋值的是引用数据类型的值，浏览器首先给这个引用数据类型开辟一个堆内存空间，然后把引用数据类型值存储到堆内存中
* （对象存键值对，数组存键值对+length、函数以字符串的形式存储函数体代码），最后把堆内存的地址赋值给变量；
*       3.3 如果函数执行：
*           3.3.1 首先开辟一个私有作用域
*           3.3.2 形参赋值。形参也是私有变量
*           3.3.3 变量提升（提升私有作用域中的变量，而且变量提升只发生在当前作用域）
*           3.3.4 函数体中的代码执行
*           3.3.5 如果没有特殊情况，释放栈内存（作用域）
*
* */

/*
* 全局变量：在全局作用域中声明的变量；
* 私有变量：在私有作用域中声明的变量、函数的形参；
* 作用域链：（scope chain）
*     是变量的查找机制：当使用变量时，浏览器会在当前作用域中查找，如果找到就使用私有变量（形参、私有变量）。
* 如果找不到，向上级作用域查找，如果找到就使用上级作用域中的，如果没找到就继续向上查找，一直找到window为止；
* 如果window还没有，此时后有两种情况：
*       如果取值（访问一个变量）就报错；
*       如果是赋值，给window添加一个属性；
*
* */

/*
* js引擎中的内存分类：
*   1、堆内存：存储引用数据类型值的。
*   2、栈内存（作用域）：供js代码执行，存储基本数据类型值
* 堆内存的创建与释放：
*   创建：当创建引用数据类型值时，浏览器会分配一块堆内存，存这个引用类型数据；
*   销毁：没有变量或者属性引用堆内存时，这块堆内存就会被释放（浏览器空闲时，会回收这些内存）
*
*
* */
var obj = {
    name: 'zhufeng'
};
var obj2 = obj;// 此时obj2和obj都引用了这个对象的堆内存；
var obj3 = {};
obj3.training = obj;//此时obj3的training属性引用了堆内存；
//释放：
var ary = [];
//把所有引用堆内存的变量或者属性赋值为null可以释放堆内存
// obj = null;
// obj2 = null;
// obj3.training = null;
// 把所有引用指向别处也会导致堆内存释放掉
obj = ary;
obj2 = ary;
obj3.training = ary;

/*
* 栈内存的创建和释放：
*   创建：
*       1. 新开一个页面会形成一个顶层栈即全局作用域
*       2. 函数执行时会开辟一个新的私有栈；
*   销毁：
*       1. 关闭页面时会释放全局栈内存；
*       2. 一般情况下，执行完就会销毁。
*   函数栈内存（私有作用域）不销毁的情况：
*       1.函数return一个引用数据类型的值，并且被函数外的变量或者对象的属性所接收
*       2.函数中的某一部分引用数据类型被外面的变量或者对象的属性占用，此时栈内存不能销毁；
*
* */
function tune() {
    return {
        name: 'zhufeng'
    }
}
var t = tune();//因为tune函数在执行后返回一个对象，且外面的t接收了，所以tune执行的栈内存不能销毁
var obj4 = {};
obj4.tune=tune();// 因为obj4的tune属性接收了tune返回的对象，所以不能销毁

//////
var x = null;
var obj5={};
(function () { //{name:...} 对象是在自执行函数的私有作用域中的，被全局变量x所占用，所以自执行函数的作用域不能销毁；
    x = {
        name: 'xf'
    };
    obj5.fn = function () { // 外面的obj5的fn属性占用了自执行函数中声明的一个函数，所以自执行函数的作用域也不能销毁
        console.log('fn');
    }
})();

/*
* let 和 const ES6新增的
* let 声明普通变量，const声明常量；
* 和var的区别：
*   1. let、const没有变量提升，如果使用let和const声明的变量要先声明后使用；
*   2. let、const不能重复声明变量，重复声明会报语法错误
*   3. let、const在全局声明的变量或者常量不会给window增加属性
*   4. let、const会使代码块变成块级作用域
*   5. TDZ: 暂时性死区，在代码块中不能在变量声明之前使用变量。
* const声明常量的细节：
*   1. 声明常量不能修改；
*   2. 声明常量就需要赋值；
*   3. 如果常量代表引用数据类型，变量代表的地址不能改，但可以修改引用数据类型的值。
* */

const VALUES = '成就他人，成就自己';
const MY_INDEX_SORT = 12; // 声明常量时大家喜欢用大写字母，每个单词用下划线分隔；




