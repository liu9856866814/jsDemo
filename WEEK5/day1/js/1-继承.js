// 面向对象：
// 封装：单例（高级单例）、工厂模式、构造函数、原型模式
// 多态：（重写、重载）JS严格来说没有重载，模拟重载（根据不同参数做不同处理）

function A() {
    // 通过 this.xxx = xxx; 方式添加的才是A类的实例私有的属性或者方法;
    this.text = 'A类的text';
}

A.prototype.say = function () { // 写在原型上的方法或者属性都是A类仅有的属性和方法
    console.log('hello world');
};
let a = new A(); // {text: '...', __proto__: '...'}
console.log(a);
a.say(); // 对象.属性名 访问对象的某个属性时,先找私有->再找所属类的原型->再往上查找一直找到基类的prototype有就使用,
// 没有返回undefined;

function B() {

}
let b = new B();
b.say(); // b的私有和公有属性都没有say方法,所以值为undefined;而undefined不能被执行,所以会报错;

// 现在我们需要让b能够调用到A类上的say这个方法;
// 我们能够让b调用say方法的前提是,say方法要么是b的私有属性,要么是b的公有属性;此时我们需要继承来实现,让B类继承A类;
// 让B类继承A类,我们称B类为子类,A类为父类(超类);所谓继承就是让子类的实例能够访问父类的属性和方法,继承就是把父类的私有属性
// 或者公有属性变成子类的私有属性或者公有属性;





